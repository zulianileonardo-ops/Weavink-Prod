#!/usr/bin/env node
/**
 * Pinecone vs Qdrant Benchmark for Weavink
 *
 * Benchmarks real use cases from Weavink app:
 * 1. Contact Similarity Search (semantic search for similar contacts)
 * 2. Semantic Scoring (fetch 2 vectors + cosine similarity for matching)
 * 3. Bulk Upsert Performance (insert contact embeddings)
 * 4. Filtered Search (query with metadata filters)
 *
 * Requirements:
 * - npm install @pinecone-database/pinecone @qdrant/js-client-rest chalk dotenv
 * - pinecone_export.json (generated by pinecone_export.py)
 * - .env file with PINECONE_API_KEY
 */

import { Pinecone } from '@pinecone-database/pinecone';
import { QdrantClient } from '@qdrant/js-client-rest';
import fs from 'fs';
import chalk from 'chalk';
import dotenv from 'dotenv';

// Load environment variables from .env
dotenv.config();

// ============================================================================
// CONFIGURATION
// ============================================================================

const CONFIG = {
  // Pinecone config
  PINECONE_API_KEY: process.env.PINECONE_API_KEY,
  PINECONE_INDEX: 'weavink',
  PINECONE_HOST: 'weavink-z1mz108.svc.aped-4627-b74a.pinecone.io',

  // Qdrant config (from user)
  QDRANT_URL: process.env.QDRANT_URL || 'http://qdrant-qkkkc8kskocgwo0o8c444cgo:6333',
  QDRANT_FALLBACK_URL: 'http://10.0.4.2:6333',

  // Test config
  ITERATIONS: 10,  // Number of iterations per test for statistical significance
  EMBEDDING_DIMENSION: 1024,  // multilingual-e5-large
  WARMUP_ITERATIONS: 2,  // Warmup runs (not counted in stats)

  // Data file
  DATA_FILE: './pinecone_export.json',
};

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Calculate statistics from an array of numbers
 */
function calculateStats(values) {
  if (!values || values.length === 0) {
    return { min: 0, max: 0, avg: 0, p50: 0, p95: 0, p99: 0 };
  }

  const sorted = [...values].sort((a, b) => a - b);
  const sum = sorted.reduce((acc, val) => acc + val, 0);

  return {
    min: sorted[0],
    max: sorted[sorted.length - 1],
    avg: sum / sorted.length,
    p50: sorted[Math.floor(sorted.length * 0.5)],
    p95: sorted[Math.floor(sorted.length * 0.95)],
    p99: sorted[Math.floor(sorted.length * 0.99)],
  };
}

/**
 * Format milliseconds with color
 */
function formatMs(ms, baseline = null) {
  const formatted = `${ms.toFixed(2)}ms`;
  if (baseline === null) return chalk.cyan(formatted);

  const diff = ms - baseline;
  const pctDiff = ((diff / baseline) * 100).toFixed(1);

  if (diff < 0) {
    return chalk.green(`${formatted} (${pctDiff}%)`);
  } else if (diff > baseline * 0.1) {
    return chalk.red(`${formatted} (+${pctDiff}%)`);
  } else {
    return chalk.yellow(`${formatted} (+${pctDiff}%)`);
  }
}

/**
 * Cosine similarity between two vectors
 */
function cosineSimilarity(vec1, vec2) {
  let dotProduct = 0;
  let norm1 = 0;
  let norm2 = 0;

  for (let i = 0; i < vec1.length; i++) {
    dotProduct += vec1[i] * vec2[i];
    norm1 += vec1[i] * vec1[i];
    norm2 += vec2[i] * vec2[i];
  }

  return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
}

/**
 * Convert Pinecone namespace to Qdrant collection name
 * Pinecone: user_IFxPCgSA8NapEq5W8jh6yHrtJGJ2
 * Qdrant: IFxPCgSA8NapEq5W8jh6yHrtJGJ2
 */
function namespaceToCollection(namespace) {
  if (namespace.startsWith('user_')) {
    return namespace.substring(5);  // Remove 'user_' prefix
  }
  return namespace;
}

/**
 * Convert Qdrant collection back to Pinecone namespace
 */
function collectionToNamespace(collection) {
  return `user_${collection}`;
}

// ============================================================================
// DATA LOADING
// ============================================================================

/**
 * Load exported vectors from pinecone_export.json
 */
function loadVectors() {
  console.log(chalk.blue('\nüì¶ Loading vectors from pinecone_export.json...\n'));

  if (!fs.existsSync(CONFIG.DATA_FILE)) {
    throw new Error(`Data file not found: ${CONFIG.DATA_FILE}`);
  }

  const data = JSON.parse(fs.readFileSync(CONFIG.DATA_FILE, 'utf-8'));

  // Group by namespace
  const byNamespace = {};
  for (const vector of data) {
    const ns = vector.namespace;
    if (!byNamespace[ns]) {
      byNamespace[ns] = [];
    }
    byNamespace[ns].push(vector);
  }

  console.log(chalk.green(`‚úÖ Loaded ${data.length} vectors across ${Object.keys(byNamespace).length} namespaces\n`));

  // Show namespace breakdown
  for (const [ns, vectors] of Object.entries(byNamespace)) {
    console.log(`   ${ns}: ${vectors.length} vectors`);
  }

  return { all: data, byNamespace };
}

// ============================================================================
// PINECONE CLIENT
// ============================================================================

class PineconeTestClient {
  constructor() {
    this.pc = new Pinecone({ apiKey: CONFIG.PINECONE_API_KEY });
    this.index = this.pc.index(CONFIG.PINECONE_INDEX);
  }

  /**
   * Test 1: Similarity Search
   * Real use case: Find contacts similar to a given contact
   */
  async similaritySearch(queryVector, namespace, topK = 10) {
    const start = Date.now();

    const results = await this.index.namespace(namespace).query({
      vector: queryVector,
      topK,
      includeMetadata: true,
    });

    return Date.now() - start;
  }

  /**
   * Test 2: Fetch Vectors (for semantic scoring)
   * Real use case: MatchingService.calculateSemanticScore - fetch 2 vectors for cosine similarity
   */
  async fetchVectors(ids, namespace) {
    const start = Date.now();

    const results = await this.index.namespace(namespace).fetch(ids);

    // Extract vectors and calculate cosine similarity (mimics real use case)
    const vectors = Object.values(results.records || {}).map(r => r.values);
    if (vectors.length >= 2) {
      const similarity = cosineSimilarity(vectors[0], vectors[1]);
    }

    return Date.now() - start;
  }

  /**
   * Test 3: Bulk Upsert
   * Real use case: Insert contact embeddings in bulk
   */
  async bulkUpsert(vectors, namespace) {
    const start = Date.now();

    // Format vectors for Pinecone
    const records = vectors.map(v => ({
      id: v.id,
      values: v.values,
      metadata: v.metadata,
    }));

    await this.index.namespace(namespace).upsert(records);

    return Date.now() - start;
  }

  /**
   * Test 4: Filtered Search
   * Real use case: Search contacts with filters (by company, tags, etc.)
   */
  async filteredSearch(queryVector, namespace, filter, topK = 10) {
    const start = Date.now();

    const results = await this.index.namespace(namespace).query({
      vector: queryVector,
      topK,
      filter,
      includeMetadata: true,
    });

    return Date.now() - start;
  }

  /**
   * Get namespace stats
   */
  async getStats(namespace) {
    const stats = await this.index.describeIndexStats();
    return stats.namespaces?.[namespace] || { vectorCount: 0 };
  }
}

// ============================================================================
// QDRANT CLIENT
// ============================================================================

class QdrantTestClient {
  constructor() {
    this.client = null;
    this.url = null;
  }

  async connect() {
    // Try primary URL first
    try {
      console.log(chalk.blue(`üîó Connecting to Qdrant at ${CONFIG.QDRANT_URL}...`));
      this.client = new QdrantClient({ url: CONFIG.QDRANT_URL });
      await this.client.getCollections();  // Test connection
      this.url = CONFIG.QDRANT_URL;
      console.log(chalk.green(`‚úÖ Connected to Qdrant at ${this.url}\n`));
      return;
    } catch (err) {
      console.log(chalk.yellow(`‚ö†Ô∏è  Primary URL failed: ${err.message}`));
    }

    // Try fallback URL
    try {
      console.log(chalk.blue(`üîó Trying fallback URL: ${CONFIG.QDRANT_FALLBACK_URL}...`));
      this.client = new QdrantClient({ url: CONFIG.QDRANT_FALLBACK_URL });
      await this.client.getCollections();  // Test connection
      this.url = CONFIG.QDRANT_FALLBACK_URL;
      console.log(chalk.green(`‚úÖ Connected to Qdrant at ${this.url}\n`));
      return;
    } catch (err) {
      throw new Error(`Failed to connect to Qdrant: ${err.message}`);
    }
  }

  /**
   * Test 1: Similarity Search
   */
  async similaritySearch(queryVector, collection, topK = 10) {
    const start = Date.now();

    const results = await this.client.search(collection, {
      vector: queryVector,
      limit: topK,
      with_payload: true,
    });

    return Date.now() - start;
  }

  /**
   * Test 2: Fetch Vectors (retrieve by IDs)
   */
  async fetchVectors(ids, collection) {
    const start = Date.now();

    const results = await this.client.retrieve(collection, {
      ids,
      with_vector: true,
    });

    // Extract vectors and calculate cosine similarity (mimics real use case)
    const vectors = results.map(r => r.vector);
    if (vectors.length >= 2) {
      const similarity = cosineSimilarity(vectors[0], vectors[1]);
    }

    return Date.now() - start;
  }

  /**
   * Test 3: Bulk Upsert
   */
  async bulkUpsert(vectors, collection) {
    const start = Date.now();

    // Format vectors for Qdrant
    const points = vectors.map(v => ({
      id: v.id,
      vector: v.values,
      payload: v.metadata,
    }));

    await this.client.upsert(collection, {
      points,
    });

    return Date.now() - start;
  }

  /**
   * Test 4: Filtered Search
   */
  async filteredSearch(queryVector, collection, filter, topK = 10) {
    const start = Date.now();

    const results = await this.client.search(collection, {
      vector: queryVector,
      limit: topK,
      filter,
      with_payload: true,
    });

    return Date.now() - start;
  }

  /**
   * Get collection stats
   */
  async getStats(collection) {
    try {
      const info = await this.client.getCollection(collection);
      return { vectorCount: info.points_count || 0 };
    } catch (err) {
      return { vectorCount: 0 };
    }
  }

  /**
   * List collections
   */
  async listCollections() {
    const result = await this.client.getCollections();
    return result.collections.map(c => c.name);
  }
}

// ============================================================================
// BENCHMARK RUNNER
// ============================================================================

class BenchmarkRunner {
  constructor(pinecone, qdrant, vectors) {
    this.pinecone = pinecone;
    this.qdrant = qdrant;
    this.vectors = vectors;
    this.results = {};
  }

  /**
   * Run a single benchmark test
   */
  async runTest(testName, testFn, warmup = true) {
    console.log(chalk.blue(`\nüß™ Test: ${testName}`));
    console.log(chalk.gray('‚îÄ'.repeat(80)));

    const pineconeLatencies = [];
    const qdrantLatencies = [];

    const totalIterations = (warmup ? CONFIG.WARMUP_ITERATIONS : 0) + CONFIG.ITERATIONS;

    // Run iterations
    for (let i = 0; i < totalIterations; i++) {
      const isWarmup = warmup && i < CONFIG.WARMUP_ITERATIONS;
      const iterLabel = isWarmup ? `Warmup ${i + 1}` : `Iteration ${i - CONFIG.WARMUP_ITERATIONS + 1}`;

      // Pinecone
      const pineconeLatency = await testFn('pinecone', i);
      if (!isWarmup) pineconeLatencies.push(pineconeLatency);

      // Qdrant
      const qdrantLatency = await testFn('qdrant', i);
      if (!isWarmup) qdrantLatencies.push(qdrantLatency);

      // Progress
      if (isWarmup) {
        console.log(chalk.gray(`  ${iterLabel}: Pinecone ${pineconeLatency.toFixed(2)}ms, Qdrant ${qdrantLatency.toFixed(2)}ms`));
      } else {
        console.log(`  ${iterLabel}: Pinecone ${pineconeLatency.toFixed(2)}ms, Qdrant ${qdrantLatency.toFixed(2)}ms`);
      }
    }

    // Calculate statistics
    const pineconeStats = calculateStats(pineconeLatencies);
    const qdrantStats = calculateStats(qdrantLatencies);

    // Store results
    this.results[testName] = {
      pinecone: pineconeStats,
      qdrant: qdrantStats,
    };

    // Print statistics
    console.log(chalk.gray('\n  Statistics (excluding warmup):'));
    console.log(chalk.cyan(`  Pinecone - Min: ${pineconeStats.min.toFixed(2)}ms, Avg: ${pineconeStats.avg.toFixed(2)}ms, P95: ${pineconeStats.p95.toFixed(2)}ms, Max: ${pineconeStats.max.toFixed(2)}ms`));
    console.log(chalk.magenta(`  Qdrant   - Min: ${qdrantStats.min.toFixed(2)}ms, Avg: ${qdrantStats.avg.toFixed(2)}ms, P95: ${qdrantStats.p95.toFixed(2)}ms, Max: ${qdrantStats.max.toFixed(2)}ms`));

    // Winner
    const winner = qdrantStats.avg < pineconeStats.avg ? 'Qdrant' : 'Pinecone';
    const speedup = ((Math.max(pineconeStats.avg, qdrantStats.avg) / Math.min(pineconeStats.avg, qdrantStats.avg)) - 1) * 100;
    console.log(chalk.green(`\n  üèÜ Winner: ${winner} (${speedup.toFixed(1)}% faster on avg)`));
  }

  /**
   * Test 1: Similarity Search
   */
  async testSimilaritySearch() {
    // Select a random namespace/collection with vectors
    const namespaces = Object.keys(this.vectors.byNamespace);
    if (namespaces.length === 0) {
      console.log(chalk.yellow('‚ö†Ô∏è  No namespaces found, skipping test'));
      return;
    }

    const testNamespace = namespaces[0];
    const testCollection = namespaceToCollection(testNamespace);
    const namespaceVectors = this.vectors.byNamespace[testNamespace];

    if (namespaceVectors.length < 2) {
      console.log(chalk.yellow('‚ö†Ô∏è  Not enough vectors in namespace, skipping test'));
      return;
    }

    // Use first vector as query
    const queryVector = namespaceVectors[0].values;

    console.log(chalk.gray(`  Using namespace: ${testNamespace} (${namespaceVectors.length} vectors)`));
    console.log(chalk.gray(`  Query: Top 10 similar contacts`));

    await this.runTest('Similarity Search (Find Similar Contacts)', async (db, iter) => {
      if (db === 'pinecone') {
        return await this.pinecone.similaritySearch(queryVector, testNamespace, 10);
      } else {
        return await this.qdrant.similaritySearch(queryVector, testCollection, 10);
      }
    });
  }

  /**
   * Test 2: Fetch Vectors (Semantic Scoring)
   */
  async testFetchVectors() {
    // Select a namespace with at least 2 vectors
    const namespaces = Object.keys(this.vectors.byNamespace);
    const testNamespace = namespaces[0];
    const testCollection = namespaceToCollection(testNamespace);
    const namespaceVectors = this.vectors.byNamespace[testNamespace];

    if (namespaceVectors.length < 2) {
      console.log(chalk.yellow('‚ö†Ô∏è  Not enough vectors, skipping test'));
      return;
    }

    // Get first 2 vector IDs
    const ids = [namespaceVectors[0].id, namespaceVectors[1].id];

    console.log(chalk.gray(`  Using namespace: ${testNamespace}`));
    console.log(chalk.gray(`  Fetching 2 vectors and calculating cosine similarity`));
    console.log(chalk.gray(`  (Mimics MatchingService.calculateSemanticScore use case)`));

    await this.runTest('Fetch Vectors + Cosine Similarity (Event Matching)', async (db, iter) => {
      if (db === 'pinecone') {
        return await this.pinecone.fetchVectors(ids, testNamespace);
      } else {
        return await this.qdrant.fetchVectors(ids, testCollection);
      }
    });
  }

  /**
   * Test 3: Bulk Upsert
   */
  async testBulkUpsert() {
    // Create a test namespace/collection
    const testNamespace = 'benchmark_test';
    const testCollection = 'benchmark_test';

    // Generate 50 test vectors
    const testVectors = [];
    for (let i = 0; i < 50; i++) {
      testVectors.push({
        id: `test_vector_${i}`,
        values: Array(CONFIG.EMBEDDING_DIMENSION).fill(0).map(() => Math.random() * 2 - 1),
        metadata: {
          name: `Test Contact ${i}`,
          company: i % 2 === 0 ? 'Acme Corp' : 'Tech Inc',
          tags: ['test', 'benchmark'],
        },
      });
    }

    console.log(chalk.gray(`  Upserting 50 test vectors`));
    console.log(chalk.gray(`  (Mimics bulk contact import use case)`));

    await this.runTest('Bulk Upsert (50 Vectors)', async (db, iter) => {
      if (db === 'pinecone') {
        return await this.pinecone.bulkUpsert(testVectors, testNamespace);
      } else {
        return await this.qdrant.bulkUpsert(testVectors, testCollection);
      }
    }, false);  // No warmup for upsert (affects data)
  }

  /**
   * Test 4: Filtered Search
   */
  async testFilteredSearch() {
    // This test requires metadata - check if any vectors have metadata
    const namespaces = Object.keys(this.vectors.byNamespace);
    const testNamespace = namespaces[0];
    const testCollection = namespaceToCollection(testNamespace);
    const namespaceVectors = this.vectors.byNamespace[testNamespace];

    if (namespaceVectors.length < 2) {
      console.log(chalk.yellow('‚ö†Ô∏è  Not enough vectors, skipping test'));
      return;
    }

    const queryVector = namespaceVectors[0].values;

    // Create a simple filter (metadata structure may vary)
    // For Pinecone: { company: 'Acme Corp' }
    // For Qdrant: { must: [{ key: 'company', match: { value: 'Acme Corp' } }] }

    console.log(chalk.gray(`  Using namespace: ${testNamespace}`));
    console.log(chalk.gray(`  Query: Top 10 with metadata filter`));
    console.log(chalk.gray(`  (Note: Filter effectiveness depends on metadata availability)`));

    await this.runTest('Filtered Search (With Metadata Filter)', async (db, iter) => {
      if (db === 'pinecone') {
        // Pinecone filter (may not match any vectors if metadata not present)
        const filter = { company: { $exists: true } };
        return await this.pinecone.filteredSearch(queryVector, testNamespace, filter, 10);
      } else {
        // Qdrant filter
        const filter = {
          must: [
            { key: 'company', match: { value: 'Acme Corp' } }
          ]
        };
        return await this.qdrant.filteredSearch(queryVector, testCollection, filter, 10);
      }
    });
  }

  /**
   * Print final comparison table
   */
  printComparisonTable() {
    console.log(chalk.blue('\n\nüìä FINAL COMPARISON TABLE'));
    console.log(chalk.gray('‚ïê'.repeat(120)));

    // Header
    console.log(
      chalk.bold(
        `${'Test'.padEnd(45)} | ${'Pinecone Avg'.padEnd(15)} | ${'Qdrant Avg'.padEnd(15)} | ${'Winner'.padEnd(15)} | ${'Speedup'}`
      )
    );
    console.log(chalk.gray('‚îÄ'.repeat(120)));

    // Rows
    for (const [testName, stats] of Object.entries(this.results)) {
      const pAvg = stats.pinecone.avg.toFixed(2);
      const qAvg = stats.qdrant.avg.toFixed(2);
      const winner = parseFloat(qAvg) < parseFloat(pAvg) ? 'Qdrant' : 'Pinecone';
      const faster = parseFloat(qAvg) < parseFloat(pAvg) ? stats.pinecone.avg : stats.qdrant.avg;
      const slower = parseFloat(qAvg) < parseFloat(pAvg) ? stats.qdrant.avg : stats.pinecone.avg;
      const speedup = (((faster / slower) - 1) * 100).toFixed(1);

      const winnerColor = winner === 'Qdrant' ? chalk.green : chalk.cyan;

      console.log(
        `${testName.padEnd(45)} | ${pAvg.padEnd(13)}ms | ${qAvg.padEnd(13)}ms | ${winnerColor(winner.padEnd(15))} | ${speedup}%`
      );
    }

    console.log(chalk.gray('‚ïê'.repeat(120)));

    // Overall recommendation
    console.log(chalk.blue('\nüìà RECOMMENDATIONS:\n'));

    let qdrantWins = 0;
    let pineconeWins = 0;

    for (const [testName, stats] of Object.entries(this.results)) {
      if (stats.qdrant.avg < stats.pinecone.avg) {
        qdrantWins++;
      } else {
        pineconeWins++;
      }
    }

    if (qdrantWins > pineconeWins) {
      console.log(chalk.green(`‚úÖ Qdrant wins ${qdrantWins} out of ${Object.keys(this.results).length} tests`));
      console.log(chalk.gray('   ‚Üí Qdrant is generally faster for your use cases'));
      console.log(chalk.gray('   ‚Üí Consider migrating to self-hosted Qdrant for better performance'));
    } else if (pineconeWins > qdrantWins) {
      console.log(chalk.cyan(`‚úÖ Pinecone wins ${pineconeWins} out of ${Object.keys(this.results).length} tests`));
      console.log(chalk.gray('   ‚Üí Pinecone is generally faster for your use cases'));
      console.log(chalk.gray('   ‚Üí Consider staying with Pinecone for managed service benefits'));
    } else {
      console.log(chalk.yellow(`‚öñÔ∏è  Tie: ${qdrantWins} wins each`));
      console.log(chalk.gray('   ‚Üí Performance is comparable between both databases'));
      console.log(chalk.gray('   ‚Üí Decision should be based on cost, operations, and self-hosting preference'));
    }

    console.log(chalk.blue('\nüí° Use Case Specific Recommendations:\n'));

    for (const [testName, stats] of Object.entries(this.results)) {
      const winner = stats.qdrant.avg < stats.pinecone.avg ? 'Qdrant' : 'Pinecone';
      const winnerColor = winner === 'Qdrant' ? chalk.green : chalk.cyan;
      console.log(`   ${testName}: ${winnerColor(winner)}`);
    }

    console.log('\n');
  }
}

// ============================================================================
// MAIN
// ============================================================================

async function main() {
  console.log(chalk.bold.blue('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'));
  console.log(chalk.bold.blue('‚ïë        Pinecone vs Qdrant Benchmark for Weavink              ‚ïë'));
  console.log(chalk.bold.blue('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n'));

  try {
    // Load vectors
    const vectors = loadVectors();

    // Initialize clients
    console.log(chalk.blue('üîß Initializing database clients...\n'));

    const pinecone = new PineconeTestClient();
    console.log(chalk.green('‚úÖ Pinecone client initialized'));

    const qdrant = new QdrantTestClient();
    await qdrant.connect();

    // Verify data
    console.log(chalk.blue('\nüìä Verifying data in both databases...\n'));

    const namespaces = Object.keys(vectors.byNamespace);
    for (const namespace of namespaces.slice(0, 3)) {  // Check first 3
      const collection = namespaceToCollection(namespace);

      const pStats = await pinecone.getStats(namespace);
      const qStats = await qdrant.getStats(collection);

      console.log(`  ${namespace}:`);
      console.log(`    Pinecone: ${pStats.vectorCount || 0} vectors`);
      console.log(`    Qdrant (${collection}): ${qStats.vectorCount || 0} vectors`);
    }

    // Run benchmarks
    console.log(chalk.blue('\n\nüöÄ Starting benchmarks...\n'));
    console.log(chalk.gray(`Configuration:`));
    console.log(chalk.gray(`  - Iterations: ${CONFIG.ITERATIONS} (+ ${CONFIG.WARMUP_ITERATIONS} warmup)`));
    console.log(chalk.gray(`  - Embedding dimension: ${CONFIG.EMBEDDING_DIMENSION}`));

    const runner = new BenchmarkRunner(pinecone, qdrant, vectors);

    // Run tests
    await runner.testSimilaritySearch();
    await runner.testFetchVectors();
    await runner.testBulkUpsert();
    await runner.testFilteredSearch();

    // Print final comparison
    runner.printComparisonTable();

    console.log(chalk.green('\n‚úÖ Benchmark complete!\n'));

  } catch (error) {
    console.error(chalk.red('\n‚ùå Benchmark failed:'), error.message);
    console.error(error.stack);
    process.exit(1);
  }
}

main();
